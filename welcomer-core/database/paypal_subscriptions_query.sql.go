// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: paypal_subscriptions_query.sql

package database

import (
	"context"
	"time"
)

const CreateOrUpdatePaypalSubscription = `-- name: CreateOrUpdatePaypalSubscription :one
INSERT INTO paypal_subscriptions (subscription_id, created_at, updated_at, user_id, payer_id, last_billed_at, next_billing_at, subscription_status, plan_id, quantity)
    VALUES ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT(subscription_id) DO UPDATE
    SET updated_at = EXCLUDED.updated_at,
        user_id = EXCLUDED.user_id,
        payer_id = EXCLUDED.payer_id,
        last_billed_at = EXCLUDED.last_billed_at,
        next_billing_at = EXCLUDED.next_billing_at,
        subscription_status = EXCLUDED.subscription_status,
        plan_id = EXCLUDED.plan_id,
        quantity = EXCLUDED.quantity
RETURNING
    subscription_id, created_at, updated_at, user_id, payer_id, last_billed_at, next_billing_at, subscription_status, plan_id, quantity
`

type CreateOrUpdatePaypalSubscriptionParams struct {
	SubscriptionID     string    `json:"subscription_id"`
	UserID             int64     `json:"user_id"`
	PayerID            string    `json:"payer_id"`
	LastBilledAt       time.Time `json:"last_billed_at"`
	NextBillingAt      time.Time `json:"next_billing_at"`
	SubscriptionStatus string    `json:"subscription_status"`
	PlanID             string    `json:"plan_id"`
	Quantity           string    `json:"quantity"`
}

func (q *Queries) CreateOrUpdatePaypalSubscription(ctx context.Context, arg CreateOrUpdatePaypalSubscriptionParams) (*PaypalSubscriptions, error) {
	row := q.db.QueryRow(ctx, CreateOrUpdatePaypalSubscription,
		arg.SubscriptionID,
		arg.UserID,
		arg.PayerID,
		arg.LastBilledAt,
		arg.NextBillingAt,
		arg.SubscriptionStatus,
		arg.PlanID,
		arg.Quantity,
	)
	var i PaypalSubscriptions
	err := row.Scan(
		&i.SubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.PayerID,
		&i.LastBilledAt,
		&i.NextBillingAt,
		&i.SubscriptionStatus,
		&i.PlanID,
		&i.Quantity,
	)
	return &i, err
}

const GetPaypalSubscriptionBySubscriptionID = `-- name: GetPaypalSubscriptionBySubscriptionID :one
SELECT
    subscription_id, created_at, updated_at, user_id, payer_id, last_billed_at, next_billing_at, subscription_status, plan_id, quantity
FROM
    paypal_subscriptions
WHERE
    subscription_id = $1
`

func (q *Queries) GetPaypalSubscriptionBySubscriptionID(ctx context.Context, subscriptionID string) (*PaypalSubscriptions, error) {
	row := q.db.QueryRow(ctx, GetPaypalSubscriptionBySubscriptionID, subscriptionID)
	var i PaypalSubscriptions
	err := row.Scan(
		&i.SubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.PayerID,
		&i.LastBilledAt,
		&i.NextBillingAt,
		&i.SubscriptionStatus,
		&i.PlanID,
		&i.Quantity,
	)
	return &i, err
}

const GetPaypalSubscriptionsByUserID = `-- name: GetPaypalSubscriptionsByUserID :many
SELECT
    subscription_id, created_at, updated_at, user_id, payer_id, last_billed_at, next_billing_at, subscription_status, plan_id, quantity
FROM
    paypal_subscriptions
WHERE
    user_id = $1
`

func (q *Queries) GetPaypalSubscriptionsByUserID(ctx context.Context, userID int64) ([]*PaypalSubscriptions, error) {
	rows, err := q.db.Query(ctx, GetPaypalSubscriptionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PaypalSubscriptions{}
	for rows.Next() {
		var i PaypalSubscriptions
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.PayerID,
			&i.LastBilledAt,
			&i.NextBillingAt,
			&i.SubscriptionStatus,
			&i.PlanID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
