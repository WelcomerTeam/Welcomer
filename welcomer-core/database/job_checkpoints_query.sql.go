// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_checkpoints_query.sql

package database

import (
	"context"
	"time"
)

const GetJobCheckpointByName = `-- name: GetJobCheckpointByName :one
SELECT
    job_name, last_processed_ts, updated_at
FROM
    job_checkpoints
WHERE
    job_name = $1 FOR UPDATE
`

func (q *Queries) GetJobCheckpointByName(ctx context.Context, jobName string) (*JobCheckpoints, error) {
	row := q.db.QueryRow(ctx, GetJobCheckpointByName, jobName)
	var i JobCheckpoints
	err := row.Scan(&i.JobName, &i.LastProcessedTs, &i.UpdatedAt)
	return &i, err
}

const UpsertJobCheckpoint = `-- name: UpsertJobCheckpoint :exec
INSERT INTO job_checkpoints (job_name, last_processed_ts, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (job_name) DO UPDATE SET
    last_processed_ts = EXCLUDED.last_processed_ts,
    updated_at = NOW()
`

type UpsertJobCheckpointParams struct {
	JobName         string    `json:"job_name"`
	LastProcessedTs time.Time `json:"last_processed_ts"`
}

func (q *Queries) UpsertJobCheckpoint(ctx context.Context, arg UpsertJobCheckpointParams) error {
	_, err := q.db.Exec(ctx, UpsertJobCheckpoint, arg.JobName, arg.LastProcessedTs)
	return err
}
