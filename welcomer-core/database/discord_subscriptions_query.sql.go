// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discord_subscriptions_query.sql

package database

import (
	"context"
	"database/sql"
)

const CreateOrUpdateDiscordSubscription = `-- name: CreateOrUpdateDiscordSubscription :one
INSERT INTO discord_subscriptions (subscription_id, created_at, updated_at, user_id, gift_code_flags, guild_id, starts_at, ends_at, sku_id, application_id, entitlement_type, deleted, consumed)
    VALUES ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT(subscription_id) DO UPDATE
    SET updated_at = EXCLUDED.updated_at,
        user_id = EXCLUDED.user_id,
        gift_code_flags = EXCLUDED.gift_code_flags,
        guild_id = EXCLUDED.guild_id,
        starts_at = EXCLUDED.starts_at,
        ends_at = EXCLUDED.ends_at,
        sku_id = EXCLUDED.sku_id,
        application_id = EXCLUDED.application_id,
        entitlement_type = EXCLUDED.entitlement_type,
        deleted = EXCLUDED.deleted,
        consumed = EXCLUDED.consumed
RETURNING
    subscription_id, created_at, updated_at, user_id, gift_code_flags, guild_id, starts_at, ends_at, sku_id, application_id, entitlement_type, deleted, consumed
`

type CreateOrUpdateDiscordSubscriptionParams struct {
	SubscriptionID  string        `json:"subscription_id"`
	UserID          int64         `json:"user_id"`
	GiftCodeFlags   sql.NullInt64 `json:"gift_code_flags"`
	GuildID         sql.NullInt64 `json:"guild_id"`
	StartsAt        sql.NullTime  `json:"starts_at"`
	EndsAt          sql.NullTime  `json:"ends_at"`
	SkuID           int64         `json:"sku_id"`
	ApplicationID   int64         `json:"application_id"`
	EntitlementType int64         `json:"entitlement_type"`
	Deleted         bool          `json:"deleted"`
	Consumed        bool          `json:"consumed"`
}

func (q *Queries) CreateOrUpdateDiscordSubscription(ctx context.Context, arg CreateOrUpdateDiscordSubscriptionParams) (*DiscordSubscriptions, error) {
	row := q.db.QueryRow(ctx, CreateOrUpdateDiscordSubscription,
		arg.SubscriptionID,
		arg.UserID,
		arg.GiftCodeFlags,
		arg.GuildID,
		arg.StartsAt,
		arg.EndsAt,
		arg.SkuID,
		arg.ApplicationID,
		arg.EntitlementType,
		arg.Deleted,
		arg.Consumed,
	)
	var i DiscordSubscriptions
	err := row.Scan(
		&i.SubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.GiftCodeFlags,
		&i.GuildID,
		&i.StartsAt,
		&i.EndsAt,
		&i.SkuID,
		&i.ApplicationID,
		&i.EntitlementType,
		&i.Deleted,
		&i.Consumed,
	)
	return &i, err
}

const GetDiscordSubscriptionsByUserID = `-- name: GetDiscordSubscriptionsByUserID :many
SELECT
    subscription_id, created_at, updated_at, user_id, gift_code_flags, guild_id, starts_at, ends_at, sku_id, application_id, entitlement_type, deleted, consumed
FROM
    discord_subscriptions
WHERE
    user_id = $1
`

func (q *Queries) GetDiscordSubscriptionsByUserID(ctx context.Context, userID int64) ([]*DiscordSubscriptions, error) {
	rows, err := q.db.Query(ctx, GetDiscordSubscriptionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DiscordSubscriptions{}
	for rows.Next() {
		var i DiscordSubscriptions
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.GiftCodeFlags,
			&i.GuildID,
			&i.StartsAt,
			&i.EndsAt,
			&i.SkuID,
			&i.ApplicationID,
			&i.EntitlementType,
			&i.Deleted,
			&i.Consumed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
