// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package welcomer

import (
	"errors"
	"fmt"
)

const (
	// BackgroundTypeDefault is a BackgroundType of type Default.
	BackgroundTypeDefault BackgroundType = iota
	// BackgroundTypeWelcomer is a BackgroundType of type Welcomer.
	BackgroundTypeWelcomer
	// BackgroundTypeSolid is a BackgroundType of type Solid.
	BackgroundTypeSolid
	// BackgroundTypeSolidProfile is a BackgroundType of type SolidProfile.
	BackgroundTypeSolidProfile
	// BackgroundTypeUnsplash is a BackgroundType of type Unsplash.
	BackgroundTypeUnsplash
	// BackgroundTypeUrl is a BackgroundType of type Url.
	BackgroundTypeUrl
	// BackgroundTypeStripes is a BackgroundType of type Stripes.
	BackgroundTypeStripes
)

var ErrInvalidBackgroundType = errors.New("not a valid BackgroundType")

const _BackgroundTypeName = "defaultwelcomersolidsolidProfileunsplashurlstripes"

var _BackgroundTypeMap = map[BackgroundType]string{
	BackgroundTypeDefault:      _BackgroundTypeName[0:7],
	BackgroundTypeWelcomer:     _BackgroundTypeName[7:15],
	BackgroundTypeSolid:        _BackgroundTypeName[15:20],
	BackgroundTypeSolidProfile: _BackgroundTypeName[20:32],
	BackgroundTypeUnsplash:     _BackgroundTypeName[32:40],
	BackgroundTypeUrl:          _BackgroundTypeName[40:43],
	BackgroundTypeStripes:      _BackgroundTypeName[43:50],
}

// String implements the Stringer interface.
func (x BackgroundType) String() string {
	if str, ok := _BackgroundTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("BackgroundType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BackgroundType) IsValid() bool {
	_, ok := _BackgroundTypeMap[x]
	return ok
}

var _BackgroundTypeValue = map[string]BackgroundType{
	_BackgroundTypeName[0:7]:   BackgroundTypeDefault,
	_BackgroundTypeName[7:15]:  BackgroundTypeWelcomer,
	_BackgroundTypeName[15:20]: BackgroundTypeSolid,
	_BackgroundTypeName[20:32]: BackgroundTypeSolidProfile,
	_BackgroundTypeName[32:40]: BackgroundTypeUnsplash,
	_BackgroundTypeName[40:43]: BackgroundTypeUrl,
	_BackgroundTypeName[43:50]: BackgroundTypeStripes,
}

// ParseBackgroundType attempts to convert a string to a BackgroundType.
func ParseBackgroundType(name string) (BackgroundType, error) {
	if x, ok := _BackgroundTypeValue[name]; ok {
		return x, nil
	}
	return BackgroundType(0), fmt.Errorf("%s is %w", name, ErrInvalidBackgroundType)
}

// MarshalText implements the text marshaller method.
func (x BackgroundType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BackgroundType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseBackgroundType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BackgroundType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageAlignmentLeft is a ImageAlignment of type Left.
	ImageAlignmentLeft ImageAlignment = iota
	// ImageAlignmentCenter is a ImageAlignment of type Center.
	ImageAlignmentCenter
	// ImageAlignmentRight is a ImageAlignment of type Right.
	ImageAlignmentRight
	// ImageAlignmentTopLeft is a ImageAlignment of type TopLeft.
	ImageAlignmentTopLeft
	// ImageAlignmentTopCenter is a ImageAlignment of type TopCenter.
	ImageAlignmentTopCenter
	// ImageAlignmentTopRight is a ImageAlignment of type TopRight.
	ImageAlignmentTopRight
	// ImageAlignmentBottomLeft is a ImageAlignment of type BottomLeft.
	ImageAlignmentBottomLeft
	// ImageAlignmentBottomCenter is a ImageAlignment of type BottomCenter.
	ImageAlignmentBottomCenter
	// ImageAlignmentBottomRight is a ImageAlignment of type BottomRight.
	ImageAlignmentBottomRight
)

var ErrInvalidImageAlignment = errors.New("not a valid ImageAlignment")

const _ImageAlignmentName = "leftcenterrighttopLefttopCentertopRightbottomLeftbottomCenterbottomRight"

var _ImageAlignmentMap = map[ImageAlignment]string{
	ImageAlignmentLeft:         _ImageAlignmentName[0:4],
	ImageAlignmentCenter:       _ImageAlignmentName[4:10],
	ImageAlignmentRight:        _ImageAlignmentName[10:15],
	ImageAlignmentTopLeft:      _ImageAlignmentName[15:22],
	ImageAlignmentTopCenter:    _ImageAlignmentName[22:31],
	ImageAlignmentTopRight:     _ImageAlignmentName[31:39],
	ImageAlignmentBottomLeft:   _ImageAlignmentName[39:49],
	ImageAlignmentBottomCenter: _ImageAlignmentName[49:61],
	ImageAlignmentBottomRight:  _ImageAlignmentName[61:72],
}

// String implements the Stringer interface.
func (x ImageAlignment) String() string {
	if str, ok := _ImageAlignmentMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageAlignment(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageAlignment) IsValid() bool {
	_, ok := _ImageAlignmentMap[x]
	return ok
}

var _ImageAlignmentValue = map[string]ImageAlignment{
	_ImageAlignmentName[0:4]:   ImageAlignmentLeft,
	_ImageAlignmentName[4:10]:  ImageAlignmentCenter,
	_ImageAlignmentName[10:15]: ImageAlignmentRight,
	_ImageAlignmentName[15:22]: ImageAlignmentTopLeft,
	_ImageAlignmentName[22:31]: ImageAlignmentTopCenter,
	_ImageAlignmentName[31:39]: ImageAlignmentTopRight,
	_ImageAlignmentName[39:49]: ImageAlignmentBottomLeft,
	_ImageAlignmentName[49:61]: ImageAlignmentBottomCenter,
	_ImageAlignmentName[61:72]: ImageAlignmentBottomRight,
}

// ParseImageAlignment attempts to convert a string to a ImageAlignment.
func ParseImageAlignment(name string) (ImageAlignment, error) {
	if x, ok := _ImageAlignmentValue[name]; ok {
		return x, nil
	}
	return ImageAlignment(0), fmt.Errorf("%s is %w", name, ErrInvalidImageAlignment)
}

// MarshalText implements the text marshaller method.
func (x ImageAlignment) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageAlignment) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseImageAlignment(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageAlignment) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageFileTypeUnknown is a ImageFileType of type Unknown.
	ImageFileTypeUnknown ImageFileType = iota
	// ImageFileTypeImagePng is a ImageFileType of type Image/Png.
	ImageFileTypeImagePng
	// ImageFileTypeImageJpeg is a ImageFileType of type Image/Jpeg.
	ImageFileTypeImageJpeg
	// ImageFileTypeImageGif is a ImageFileType of type Image/Gif.
	ImageFileTypeImageGif
	// ImageFileTypeImageWebp is a ImageFileType of type Image/Webp.
	ImageFileTypeImageWebp
)

var ErrInvalidImageFileType = errors.New("not a valid ImageFileType")

const _ImageFileTypeName = "unknownimage/pngimage/jpegimage/gifimage/webp"

var _ImageFileTypeMap = map[ImageFileType]string{
	ImageFileTypeUnknown:   _ImageFileTypeName[0:7],
	ImageFileTypeImagePng:  _ImageFileTypeName[7:16],
	ImageFileTypeImageJpeg: _ImageFileTypeName[16:26],
	ImageFileTypeImageGif:  _ImageFileTypeName[26:35],
	ImageFileTypeImageWebp: _ImageFileTypeName[35:45],
}

// String implements the Stringer interface.
func (x ImageFileType) String() string {
	if str, ok := _ImageFileTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageFileType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageFileType) IsValid() bool {
	_, ok := _ImageFileTypeMap[x]
	return ok
}

var _ImageFileTypeValue = map[string]ImageFileType{
	_ImageFileTypeName[0:7]:   ImageFileTypeUnknown,
	_ImageFileTypeName[7:16]:  ImageFileTypeImagePng,
	_ImageFileTypeName[16:26]: ImageFileTypeImageJpeg,
	_ImageFileTypeName[26:35]: ImageFileTypeImageGif,
	_ImageFileTypeName[35:45]: ImageFileTypeImageWebp,
}

// ParseImageFileType attempts to convert a string to a ImageFileType.
func ParseImageFileType(name string) (ImageFileType, error) {
	if x, ok := _ImageFileTypeValue[name]; ok {
		return x, nil
	}
	return ImageFileType(0), fmt.Errorf("%s is %w", name, ErrInvalidImageFileType)
}

// MarshalText implements the text marshaller method.
func (x ImageFileType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageFileType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseImageFileType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageFileType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageProfileBorderTypeCircular is a ImageProfileBorderType of type Circular.
	ImageProfileBorderTypeCircular ImageProfileBorderType = iota
	// ImageProfileBorderTypeRounded is a ImageProfileBorderType of type Rounded.
	ImageProfileBorderTypeRounded
	// ImageProfileBorderTypeSquared is a ImageProfileBorderType of type Squared.
	ImageProfileBorderTypeSquared
	// ImageProfileBorderTypeHexagonal is a ImageProfileBorderType of type Hexagonal.
	ImageProfileBorderTypeHexagonal
)

var ErrInvalidImageProfileBorderType = errors.New("not a valid ImageProfileBorderType")

const _ImageProfileBorderTypeName = "circularroundedsquaredhexagonal"

var _ImageProfileBorderTypeMap = map[ImageProfileBorderType]string{
	ImageProfileBorderTypeCircular:  _ImageProfileBorderTypeName[0:8],
	ImageProfileBorderTypeRounded:   _ImageProfileBorderTypeName[8:15],
	ImageProfileBorderTypeSquared:   _ImageProfileBorderTypeName[15:22],
	ImageProfileBorderTypeHexagonal: _ImageProfileBorderTypeName[22:31],
}

// String implements the Stringer interface.
func (x ImageProfileBorderType) String() string {
	if str, ok := _ImageProfileBorderTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageProfileBorderType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageProfileBorderType) IsValid() bool {
	_, ok := _ImageProfileBorderTypeMap[x]
	return ok
}

var _ImageProfileBorderTypeValue = map[string]ImageProfileBorderType{
	_ImageProfileBorderTypeName[0:8]:   ImageProfileBorderTypeCircular,
	_ImageProfileBorderTypeName[8:15]:  ImageProfileBorderTypeRounded,
	_ImageProfileBorderTypeName[15:22]: ImageProfileBorderTypeSquared,
	_ImageProfileBorderTypeName[22:31]: ImageProfileBorderTypeHexagonal,
}

// ParseImageProfileBorderType attempts to convert a string to a ImageProfileBorderType.
func ParseImageProfileBorderType(name string) (ImageProfileBorderType, error) {
	if x, ok := _ImageProfileBorderTypeValue[name]; ok {
		return x, nil
	}
	return ImageProfileBorderType(0), fmt.Errorf("%s is %w", name, ErrInvalidImageProfileBorderType)
}

// MarshalText implements the text marshaller method.
func (x ImageProfileBorderType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageProfileBorderType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseImageProfileBorderType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageProfileBorderType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageThemeDefault is a ImageTheme of type Default.
	ImageThemeDefault ImageTheme = iota
	// ImageThemeVertical is a ImageTheme of type Vertical.
	ImageThemeVertical
	// ImageThemeCard is a ImageTheme of type Card.
	ImageThemeCard
)

var ErrInvalidImageTheme = errors.New("not a valid ImageTheme")

const _ImageThemeName = "defaultverticalcard"

var _ImageThemeMap = map[ImageTheme]string{
	ImageThemeDefault:  _ImageThemeName[0:7],
	ImageThemeVertical: _ImageThemeName[7:15],
	ImageThemeCard:     _ImageThemeName[15:19],
}

// String implements the Stringer interface.
func (x ImageTheme) String() string {
	if str, ok := _ImageThemeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageTheme(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageTheme) IsValid() bool {
	_, ok := _ImageThemeMap[x]
	return ok
}

var _ImageThemeValue = map[string]ImageTheme{
	_ImageThemeName[0:7]:   ImageThemeDefault,
	_ImageThemeName[7:15]:  ImageThemeVertical,
	_ImageThemeName[15:19]: ImageThemeCard,
}

// ParseImageTheme attempts to convert a string to a ImageTheme.
func ParseImageTheme(name string) (ImageTheme, error) {
	if x, ok := _ImageThemeValue[name]; ok {
		return x, nil
	}
	return ImageTheme(0), fmt.Errorf("%s is %w", name, ErrInvalidImageTheme)
}

// MarshalText implements the text marshaller method.
func (x ImageTheme) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageTheme) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseImageTheme(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageTheme) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
